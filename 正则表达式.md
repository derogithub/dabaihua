#### 捕获组
- 普通捕获组 (expression)
- 命名捕获组 (?<name>Expression) 
- PHP中的命名捕获组 (?P<name>Expression)

捕获组编号
- 只有普通捕获组:    从左到右,按照'('出现的顺序,从1开始编号.
- 只有命名捕获组:    从左到右,按照'('出现的顺序,从1开始编号.
- 普通捕获组和命名捕获组混合:    混合方式的捕获组编号，首先按照普通捕获组中“(”出现的先后顺序(环视的括号不算)，从左到右，从1开始进行编号，当普通捕获组编号完成后，再按命名捕获组中“(”出现的先后顺序，从左到右，接着普通捕获组的编号值继续进行编号。

捕获组反向引用
- 普通捕获组反向引用：\k<number>，通常简写为\number
- 命名捕获组反向引用：\k<name>或者\k'name'
- PHP中: preg_replace()中: 用\\1或$1; 引用后面跟数字字符串,用\${1}1;

#### 非捕获组

(?:Expression) 括号内的内容不会出现在捕获结果中.
1. 使用“|”表示“或”的关系时，用“()”限制范围    
    - (?:近期|近日)    匹配'近期'或'近日',并且不会出现在捕获结果中.
2. 使用量词限定一个子表达式整体的匹配次数
    - (?::[0-5][0-9]){2}    匹配HH:mm:ss格式时间中的分和秒.

辩证的使用
- 一些非常简单的正则中，如果使用了非捕获组，因为要解析这种语法，反而可能会降低匹配效率。
- 一般在较复杂，“()”使用较多的正则表达式中可以考虑使用非捕获组。

#### 平衡组    
- (?'group') 把捕获的内容命名为group,并压入堆栈(Stack)
- (?'-group') 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
- (?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
- (?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败.(?(Open)(?!)) #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的"Open"；如果还有，则匹配失败
 
例:
```
<div id='a'>this is a <div id='b'> this is b <div id='c'> this is c</div>b too </div> a too </div>
如果想匹配出上面的<div id='b'> this is b <div id='c'> this is c</div>b too </div>就可以使用平衡组
<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>
```

#### 环视
- (?<=Expression)     逆序肯定环视，表示所在位置左侧能够匹配Expression
- (?<!Expression)    逆序否定环视，表示所在位置左侧不能匹配Expression
- (?=Expression)    顺序肯定环视，表示所在位置右侧能够匹配Expression
- (?!Expression)    顺序否定环视，表示所在位置右侧不能匹配Expression

- Compilation failed: lookbehind assertion is not fixed length
- 环视需要固定长度,在php中，零宽断言里不支持类似“*”、“+”这些无限次的东西

#### 递归模式

(?R)的作用就是递归地替换它所在的整条正则表达式.

例:

用"/\((?>[^()]+|(?R))*\)/"匹配"some text (a(b(c)d)e) more text".

在每次迭代时, PHP 语法分析器都会将(?R)替换为"/\((?>[^()]+|(?R))*\)/"

#### 一次性匹配

(?>表达式) 只匹配一次,不会回溯.

